#######################################
### Liner modeling script for winTor###
#######################################

#### Extra Paths####
if (!exists('base.path')) {
  if(.Platform$"OS.type" == "windows"){
    base.path = file.path("D:", "Dropbox", "wintor_aux")
  } else {
    base.path = "~/Dropbox/winTor_aux"
  }
}

win.dat <- file.path(base.path, "data")
win.res <- file.path(base.path, "Results")
## The %!in% opperator 
'%!in%' <- function(x,y)!('%in%'(x,y))


#### Data ####
dur.df <- read.csv("data/modelingDataFrame.csv")
mass <- read.csv("data/massLocations.csv")

## Co-variates
library(raster)
env.names <- c("NA_dem", "NA_northing", "NA_nFrostyDays",
               "NA_nonGrowingDays", "NA_nDaysFreeze", "NA_OG1k")
env.stk <- raster::subset(stack(list.files(win.dat, pattern = "NA_*", full.names = T)), env.names)

## ammending mass to have co-variate data
coordinates(mass) <- ~ Long + Lat
proj4string(mass) <- proj4string(mass)
mass.df <- as.data.frame(cbind(mass, raster::extract(env.stk, mass)))


#### preliminary lm to determine potential outlier points ####

mod.form <- function(x, coVar){
  ## x is to be the item predicted
  ## covar is to be a list of the names oc covariates
  
  #univariate models
  l1 <- list()
  for(i in 1:length(coVar)){
    l1[[i]] <- as.formula(paste(x,"~",coVar[[i]]))
  }
  
  #with Norhting
  coVar2 <- coVar[-2]
  l2 <- list()
  for(i in 1:length(coVar2)){
    l2[[i]] <- as.formula(paste(x,"~",coVar[[2]],"+",coVar2[[i]]))
  }
  
  #with Northing and DEM
  coVar3 <- coVar[3:length(coVar)]
  l3 <- list()
  for(i in 1:length(coVar3)){
    l3[[i]] <- as.formula(paste(x,"~",coVar[[2]],"+",coVar[[1]],"+",coVar3[[i]]))
  }
  
  list.mods <- c(l1, l2, l3)
  
  return(list.mods)
}

library(caret)
cross.lm <- function(predictor, forms, x){
  ##function for preforming leave one out crossvalidation and determing
  ##which points are potentially over influencing the models
  # pred is to be what you want to predict
  # forms is a list of formulas generated by mod.form
  # x is the dataframe from which all the data comes from
  
  ##control statment for caret
  train_control <- trainControl(method="LOOCV", returnResamp = "all")
  
  # run the leave one out validation on each of the points and return pvals
  pred = list()
  for (i in 1:nrow(x)) {
    test = x[i,]
    train = x[-i,]
    mod = lm(forms, data=train)
    pred_fit = predict.lm(mod, test, interval="prediction", se.fit=TRUE)
    pred[[i]] <- cbind(pred_fit$fit,
                      se=pred_fit$se.fit,
                      res.scale=pred_fit$residual.scale,
                      df=pred_fit$df,
                      obs=test[,predictor])
  }
  
  pred = bind_rows(lapply(pred, as.data.frame))
  
    ## finds p val for observations, if outside of window of obs adj.pval will be low
  pval.pred <- pred %>% mutate(pred.sd = sqrt(se^2 + res.scale^2),
                               tval = (obs - fit) / pred.sd,
                               pval = 2*pt(abs(tval), df=df, lower.tail = FALSE)) %>%
    mutate(padj = p.adjust(pval)) %>% arrange(pval) %>%
    dplyr::filter(padj < 1)
  
  if(nrow(pval.pred) > 0){
    out <- list(df = as.data.frame(pval.pred),formula =  forms)  
  } else{
    out <- NA
  }

  return(out)
}

cross.wrapper <- function(predictor, coVarNames, df){
  ##function to wrapp and summarize cross.lm
  # predictor is the name of the variable to be predicted across
  # coVarNames is the list of predictor names
  # df is the name that all the junk comes from 
  
  #create model formulas
  model.formulas <- mod.form(x = predictor, coVar = coVarNames)
  
  #run crossvalidation protocol
  cross.list <- lapply(X = model.formulas,
                       FUN = cross.lm,
                       predictor = predictor,
                       x = df)
  #breaks when you have non-uniqe fitting values in the predictors
  #would need some rework with the predict dataframe managment
  # obs <- list()
  # v <- 1
  # for(i in 1:length(cross.list)){
  #   if(!is.na(cross.list[[i]])){
  #     for(j in 1:nrow(cross.list[[i]]$df))
  #       obs.sub <- cbind(df[which(df[,predictor] == cross.list[[i]]$df[j,"obs"]),],
  #                      pval = cross.list[[i]]$df[,"padj"])
  #     obs[[v]] <- list(formula = cross.list[[i]]$formula, records = obs.sub)
  #     v <- v+1
  #   }
  # }
  # 
  # return(obs)
  return(cross.list)
}


dur.points <- cross.wrapper(predictor = "winter.duration", 
                       coVarNames = env.names,
                       df = dur.df)
## No points stand out

mass.points <- cross.wrapper(predictor = "avgMass",
                             coVarNames = env.names,
                             df = mass.df)
## The 14.5 point from New York pops out in every intance and has a super low p-val

mass.df <- mass.df[-10,]

#### Linear model application ####

dur.mods <- lapply(mod.form("winter.duration",coVar = env.names),
                  FUN = lm, data = dur.df )

mass.mods <- lapply(mod.form("avgMass",coVar = env.names),
                    FUN = lm, data = mass.df )

#### AIC Model Selection ####
library(AICcmodavg)
dur.AIC <- aictab(dur.mods,
                  modnames = c("dem",
                               "northing",
                               "frost",
                               "growing",
                               "freeze",
                               "OG",
                               "north + dem",
                               "north + frost",
                               "north + growing",
                               "north + freeze",
                               "north + OG",
                               "north + dem + frost",
                               "north + dem + growing",
                               "north + dem + freeze",
                               "north + dem + OG"))

mass.AIC <- aictab(mass.mods,
                   modnames = c("dem",
                                "northing",
                                "frost",
                                "growing",
                                "freeze",
                                "OG",
                                "north + dem",
                                "north + frost",
                                "north + growing",
                                "north + freeze",
                                "north + OG",
                                "north + dem + frost",
                                "north + dem + growing",
                                "north + dem + freeze",
                                "north + dem + OG"))
##Write Tables out
write.csv(dur.AIC, file =  file.path(win.res, 'durationAICtable.csv'), row.names = F)
write.csv(mass.AIC, file =  file.path(win.res, 'massAICtable.csv'), row.names = F)

#### Predictions and confidince bounds ####
lmRasterIntervals <- function(model, coVars, outName){
  conffun <- function(model, data) {
    v <- predict(model, data, interval = "confidence")
    cbind(p=as.vector(v[,"fit"]), lwr=as.vector(v[,"lwr"]), upr=as.vector(v[,"upr"]) )
  }
  
  conf.int <- raster::predict(model, object = coVars, fun = conffun, index = 1:3)
  names(conf.int) <- c("p", "lwr", "upr")
  
  writeRaster(x = conf.int,
              filename = file.path(win.res, out.name),
              format = "GTiff",
              bylayer = T,
              suffix = "names",
              overwrite = T)
  
}




dur.top.form <- mod.form("winter.duration",coVar = env.names)[[12]]
dur.top.mod <- lm(dur.top.form, data = dur.df)
lmRasterIntervals(dur.top.mod,
                  coVars = env.stk,
                  outName = "durationRaster")


mass.top.form <- mod.form("avgMass",coVar = env.names)[[10]]
dur.top.mod <- lm(dur.top.form, data = mass.df)
lmRasterIntervals(mass.top.mod,
                  coVars = env.stk,
                  outName = "massRaster")