#######################################
### Liner modeling script for winTor###
#######################################

#### Extra Paths####
if (!exists('base.path')) {
  if(.Platform$"OS.type" == "windows"){
    base.path = file.path("D:", "Dropbox", "wintor_aux")
  } else {
    base.path = "~/Dropbox/winTor_aux"
  }
}

win.dat <- file.path(base.path, "data")
win.res <- file.path(base.path, "Results")
## The %!in% opperator 
'%!in%' <- function(x,y)!('%in%'(x,y))


#### Data ####
dur.df <- read.csv("data/durationUpdate.csv")
mass <- read.csv("data/massLocations.csv")

## Co-variates
library(raster)
env.names <- c("NA_dem", "NA_northing", "NA_nFrostyDays",
               "NA_nonGrowingDays", "NA_nDaysFreeze", "NA_OG1k")
env.stk <- raster::subset(stack(list.files(win.dat, pattern = "NA_*", full.names = T)), env.names)

## ammending mass to have co-variate data
coordinates(mass) <- ~ Long + Lat
proj4string(mass) <- proj4string(mass)
mass.df <- as.data.frame(cbind(mass, raster::extract(env.stk, mass)))


#### preliminary lm to determine potential outlier points ####

mod.form <- function(x, coVar){
  ## x is to be the item predicted
  ## covar is to be a list of the names oc covariates
  
  #univariate models
  l1 <- list()
  for(i in 1:length(coVar)){
    l1[[i]] <- as.formula(paste(x,"~",coVar[[i]]))
  }
  
  #with Norhting
  coVar2 <- coVar[-2]
  l2 <- list()
  for(i in 1:length(coVar2)){
    l2[[i]] <- as.formula(paste(x,"~",coVar[[2]],"+",coVar2[[i]]))
  }
  
  #with Northing and DEM
  coVar3 <- coVar[3:length(coVar)]
  l3 <- list()
  for(i in 1:length(coVar3)){
    l3[[i]] <- as.formula(paste(x,"~",coVar[[2]],"+",coVar[[1]],"+",coVar3[[i]]))
  }
  
  list.mods <- c(l1, l2, l3)
  
  return(list.mods)
}

library(caret)
cross.lm <- function(predictor, forms, x){
  ##function for preforming leave one out crossvalidation and determing
  ##which points are potentially over influencing the models
  # pred is to be what you want to predict
  # forms is a list of formulas generated by mod.form
  # x is the dataframe from which all the data comes from
  
  ##control statment for caret
  train_control <- trainControl(method="LOOCV", returnResamp = "all")
  
  # run the leave one out validation on each of the points and return pvals
  pred = list()
  for (i in 1:nrow(x)) {
    test = x[i,]
    train = x[-i,]
    mod = lm(forms, data=train)
    pred_fit = predict.lm(mod, test, interval="prediction", se.fit=TRUE)
    pred[[i]] <- cbind(pred_fit$fit,
                      se=pred_fit$se.fit,
                      res.scale=pred_fit$residual.scale,
                      df=pred_fit$df,
                      obs=test[,predictor])
  }
  
  pred = bind_rows(lapply(pred, as.data.frame))
  
    ## finds p val for observations, if outside of window of obs adj.pval will be low
  pval.pred <- pred %>% mutate(pred.sd = sqrt(se^2 + res.scale^2),
                               tval = (obs - fit) / pred.sd,
                               pval = 2*pt(abs(tval), df=df, lower.tail = FALSE)) %>%
    mutate(padj = p.adjust(pval)) %>% arrange(pval) %>%
    dplyr::filter(padj < 1)
  
  if(nrow(pval.pred) > 0){
    out <- list(df = as.data.frame(pval.pred),formula =  forms)  
  } else{
    out <- NA
  }

  return(out)
}

cross.wrapper <- function(predictor, coVarNames, df){
  ##function to wrapp and summarize cross.lm
  # predictor is the name of the variable to be predicted across
  # coVarNames is the list of predictor names
  # df is the name that all the junk comes from 
  
  #create model formulas
  model.formulas <- mod.form(x = predictor, coVar = coVarNames)
  
  #run crossvalidation protocol
  cross.list <- lapply(X = model.formulas,
                       FUN = cross.lm,
                       predictor = predictor,
                       x = df)
  #breaks when you have non-uniqe fitting values in the predictors
  #would need some rework with the predict dataframe managment
  # obs <- list()
  # v <- 1
  # for(i in 1:length(cross.list)){
  #   if(!is.na(cross.list[[i]])){
  #     for(j in 1:nrow(cross.list[[i]]$df))
  #       obs.sub <- cbind(df[which(df[,predictor] == cross.list[[i]]$df[j,"obs"]),],
  #                      pval = cross.list[[i]]$df[,"padj"])
  #     obs[[v]] <- list(formula = cross.list[[i]]$formula, records = obs.sub)
  #     v <- v+1
  #   }
  # }
  # 
  # return(obs)
  return(cross.list)
}


dur.points <- cross.wrapper(predictor = "winter.duration", 
                       coVarNames = env.names,
                       df = dur.df)
## 2 points, but never that low of adj p=val
## acptable adjusted p-values so I'd say they're fine

mass.points <- cross.wrapper(predictor = "avgMass",
                             coVarNames = env.names,
                             df = mass.df)
## The 14.5 point from New York pops out in every intance and has a super low p-val
mass.df <- mass.df[-which(mass.df$avgMass==14.5),]

#### Linear model application ####

dur.mods <- lapply(mod.form("winter.duration",coVar = env.names),
                  FUN = lm, data = dur.df )

mass.mods <- lapply(mod.form("avgMass",coVar = env.names),
                    FUN = lm, data = mass.df )

#### AIC Model Selection ####
library(AICcmodavg)
dur.AIC <- aictab(dur.mods,
                  modnames = c("dem",
                               "northing",
                               "frost",
                               "growing",
                               "freeze",
                               "OG",
                               "north + dem",
                               "north + frost",
                               "north + growing",
                               "north + freeze",
                               "north + OG",
                               "north + dem + frost",
                               "north + dem + growing",
                               "north + dem + freeze",
                               "north + dem + OG"))

mass.AIC <- aictab(mass.mods,
                   modnames = c("dem",
                                "northing",
                                "frost",
                                "growing",
                                "freeze",
                                "OG",
                                "north + dem",
                                "north + frost",
                                "north + growing",
                                "north + freeze",
                                "north + OG",
                                "north + dem + frost",
                                "north + dem + growing",
                                "north + dem + freeze",
                                "north + dem + OG"))
##Write Tables out
write.csv(dur.AIC, file =  file.path(win.res, 'durationAICtable.csv'), row.names = F)
write.csv(mass.AIC, file =  file.path(win.res, 'massAICtable.csv'), row.names = F)

#### Variogram of the top models ####
library(gstat)

#top model duration
dur.mod <- formula(dur.mods[[12]])
dur.mod.df <- dur.df

#Create locations points
coordinates(dur.mod.df) <- ~ long + lat
proj4string(dur.mod.df) <- proj4string(env.stk)

v <- variogram(dur.mod,
                data = dur.mod.df)
v.exp = fit.variogram(v, vgm("Exp"), fit.kappa = T)
v.mat <- fit.variogram(v, vgm("Mat"), fit.kappa = T)
v.sph <- fit.variogram(v, vgm("Sph"), fit.kappa = T)

par(mfrow = c(1,3))

plot(v, v.exp)
plot(v, v.mat)
plot(v, v.sph)

### same for Mass
mass.mod <- formula(mass.mods[[10]])
mass.mod.df <- mass.df

coordinates(mass.mod.df) <- ~ Long + Lat
proj4string(mass.mod.df) <- proj4string(env.stk)

q <- variogram(mass.mod,
               data = mass.mod.df)
q.exp = fit.variogram(q, vgm("Exp"), fit.kappa = T)
q.mat <- fit.variogram(q, vgm("Mat"), fit.kappa = T)
q.sph <- fit.variogram(q, vgm("Sph"), fit.kappa = T)

par(mfrow = c(1,3))

plot(q, q.exp)
plot(q, q.mat)
plot(q, q.sph)




#### Predictions and confidince bounds ####
lmRasterIntervals <- function(model, coVars, outName){
  conffun <- function(model, data) {
    v <- predict(model, data, interval = "confidence")
    cbind(p=as.vector(v[,"fit"]), lwr=as.vector(v[,"lwr"]), upr=as.vector(v[,"upr"]) )
  }
  
  conf.int <- raster::predict(model, object = coVars, fun = conffun, index = 1:3)
  names(conf.int) <- c("p", "lwr", "upr")
  
  writeRaster(x = conf.int,
              filename = file.path(win.res, outName),
              format = "GTiff",
              bylayer = T,
              suffix = "names",
              overwrite = T)
  
}

dur.top.form <- mod.form("winter.duration",coVar = env.names)[[3]]
dur.top.mod <- lm(dur.top.form, data = dur.df)
lmRasterIntervals(dur.top.mod,
                  coVars = env.stk,
                  outName = "durationRaster")


mass.top.form <- mod.form("avgMass",coVar = env.names)[[10]]
mass.top.mod <- lm(mass.top.form, data = mass.df)
lmRasterIntervals(mass.top.mod,
                  coVars = env.stk,
                  outName = "massRaster")
gc()
#### Creating the fat required rasters #####

library(data.table);library(raster)
survivalFat <- function(mod.df, pct.rh.rast, temp.rast, win.rast){
  #Raster modifications for Kelvin temperatures
  if(summary(temp.rast)[1] > 200){
    temp.c <- temp.rast - 273
  } else{
    temp.c <- temp.rast
  }
  
  #Creating output raster dimensions
  out <- raster(pct.rh.rast); values(out) <- NA
  out.s <- stack(out,out); names(out.s) <- c("fat.inf", "fat.null")
  
  #Extract data from rasters  to matrix for speed
  pct.rh <- as.matrix(pct.rh.rast, nrow = nrow(pct.rh.rast), ncol = ncol(pct.rh.rast))
  temp <- as.matrix(temp.c, nrow = nrow(temp.c), ncol = ncol(temp.c))
  win <- as.matrix(win.rast, nrow = nrow(win.rast), ncol = ncol(win.rast))
  
  ## shifting hours to days
  mod.dif <- mod.df %>%
    mutate_(days = ~hour.to.day(time)) 
  
  ####Look Up Table ####
  #Vectors for look up table structure
  Ta_vals <- unique(mod.dif$Ta)
  pct.rh_vals <- unique(mod.dif$pct.rh)
  days_vals <- unique(mod.dif$days)
  
  #Look Up Table
  lut <- array(NA, dim=c(length(Ta_vals), length(pct.rh_vals), length(days_vals),  2)) # 2 for fat.inf and fat.null
  dimnames(lut)[[1]] <- Ta_vals
  dimnames(lut)[[2]] <- pct.rh_vals
  dimnames(lut)[[3]] <- days_vals
  dimnames(lut)[[4]] <- c("fat.inf", "fat.null")
  
  
  #Fill look up table
  for (i in seq_len(nrow(mod.dif))) {
    d <- mod.dif[i,]
    if (i %% 10000 == 0) {
      cat("Look up table generation up to", i, "of", nrow(mod.dif), "\n")
    }
    lut[as.character(d$Ta), as.character(d$pct.rh), as.character(d$days),] <- c(d$g.fat.consumed,
                                                                                d$n.g.fat.consumed)
  }
  
  ####Find closest####
  find_closest <- function(x, y) {
    # Find the closest item in the vector y to x.
    # NOTE: Assumes that y is increasing, equi-spaced vector
    dy <- (y[length(y)] - y[1]) / (length(y)-1)
    wch <- round((x - y[1]) / dy + 1)
    # check the range.
    clamp <- function(x, xmin, xmax) {
      min(max(x, xmin),xmax)
    }
    
    clamp(wch, 1, length(y))
  }
  
  #Run lookup
  for(j in 1:nlayers(out.s)){
    #Create output matrix
    out.z <- matrix(ncol = ncol(pct.rh), nrow = nrow(pct.rh))
    for(i in 1:length(pct.rh)){
      # first find the closest humidity and Ta
      if(i %% 1000 == 0){
        cat("Raster layer: ", j, "of", nlayers(out.s), "up to", i, "of", length(pct.rh), "\n")
      }
      pct.rh_i <- find_closest(pct.rh[[i]], pct.rh_vals)
      Ta_i  <- find_closest(temp[[i]], Ta_vals)
      win_i <- find_closest(win[[i]], days_vals)
      out.z[[i]] <- lut[Ta_i, pct.rh_i, win_i, j]
    }
    # Set values back from matrix to raster
    out.s[[j]] <- setValues(out.s[[j]], out.z)
  }
  return(out.s)
}
# mod.big <- fread("D://Dropbox/winTor_aux/data/myluModHUGE.csv")
# win <- raster(file.path(win.res, "durationRaster_p.tif"))
# rh <- raster("D://Dropbox/batwintor_aux/paramFiles/RH_NA.tif")
# mat <- raster("D://WorldClim/bclim/bio_1.bil")
# 
# rh.fix <- projectRaster(rh, win); rm(rh)
# mat. <- projectRaster(mat, win); rm(mat)
# mat.fix <- calc(mat., function(x){x/10}); rm(mat.)
# 
# library(batwintor)
# 
# fat.rast <- survivalFat(mod.df = mod.big,
#                         pct.rh.rast = rh.fix,
#                         temp.rast = mat.fix,
#                         win.rast = win)
# writeRaster(fat.rast,
#             filename = file.path(win.res, "MYLU_fatRequired.tif"),
#             format = "GTiff",
#             bylayer = T,
#             suffix = "names",
#             overwrite = T)

## Creating alternative hibernatin estimate ones
library(data.table);library(raster)

mod.alt <- fread("D://Dropbox/winTor_aux/data/myluHibernation_Alt.csv")
win <- raster(file.path(win.res, "durationRaster_p.tif"))
rh <- raster("D://Dropbox/batwintor_aux/paramFiles/RH_NA.tif")
mat <- raster("D://WorldClim/bclim/bio_1.bil")

rh.fix <- projectRaster(rh, win); rm(rh)
mat. <- projectRaster(mat, win); rm(mat)
mat.fix <- calc(mat., function(x){x/10}); rm(mat.)

## Exchange for 4 and 98
temp4 <- calc(mat.fix, function(x) ifelse(!is.na(x),4,NA))
rh98 <- calc(rh.fix, function(x) ifelse(!is.na(x), 98, NA))


library(batwintor)

fat.rast <- survivalFat(mod.df = mod.alt,
                        pct.rh.rast = rh98,
                        temp.rast = temp4,
                        win.rast = win)
writeRaster(fat.rast,
            filename = file.path(win.res, "MYLU_fatRequired_98_4_Alt.tif"),
            format = "GTiff",
            bylayer = T,
            suffix = "names",
            overwrite = T)
#### uncertianty win ####
win.lwr <- raster(file.path(win.res, "durationRaster_lwr.tif"))

fat.lwr <- survivalFat(mod.df = mod.big,
                       pct.rh.rast = rh.fix,
                       temp.rast = mat.fix,
                       win.rast = win.lwr)

writeRaster(fat.lwr,
            filename = file.path(win.res, "MYLU_fatRequired_LWR.tif"),
            format = "GTiff",
            bylayer = T,
            suffix = "names",
            overwrite = T)
rm(win.lwr, fat.lwr)
gc()


win.upr <- raster(file.path(win.res, "durationRaster_upr.tif"))

fat.upr <- survivalFat(mod.df = mod.big,
                       pct.rh.rast = rh.fix,
                       temp.rast = mat.fix,
                       win.rast = win.upr)

writeRaster(fat.upr,
            filename = file.path(win.res, "MYLU_fatRequired_upr.tif"),
            format = "GTiff",
            bylayer = T,
            suffix = "names",
            overwrite = T)
rm(win.upr, fat.upr)
gc()

#### Fixed conditions ####
## create mock laters to represent bats choosing to hibernate at 98% and 4deg

temp4 <- calc(mat.fix, function(x) ifelse(!is.na(x),4,NA))
rh98 <- calc(rh.fix, function(x) ifelse(!is.na(x), 98, NA))

fat.rast <- survivalFat(mod.df = mod.big,
                        pct.rh.rast = rh98,
                        temp.rast = temp4,
                        win.rast = win)
writeRaster(fat.rast,
            filename = file.path(win.res, "MYLU_fatRequired_98_4.tif"),
            format = "GTiff",
            bylayer = T,
            suffix = "names",
            overwrite = T)
rm(fat.rast)


#
win.lwr <- raster(file.path(win.res, "durationRaster_lwr.tif"))


fat.lwr <- survivalFat(mod.df = mod.big,
                       pct.rh.rast = rh98,
                       temp.rast = temp4,
                       win.rast = win.lwr)

writeRaster(fat.lwr,
            filename = file.path(win.res, "MYLU_fatRequired_lwr_98_4.tif"),
            format = "GTiff",
            bylayer = T,
            suffix = "names",
            overwrite = T)
rm(win.lwr, fat.lwr)
gc()


win.upr <- raster(file.path(win.res, "durationRaster_upr.tif"))

fat.upr <- survivalFat(mod.df = mod.big,
                       pct.rh.rast = rh98,
                       temp.rast = temp4,
                       win.rast = win.upr)

writeRaster(fat.upr,
            filename = file.path(win.res, "MYLU_fatRequired_upr_98_4.tif"),
            format = "GTiff",
            bylayer = T,
            suffix = "names",
            overwrite = T)
rm(win.upr, fat.upr)

#### fixed 2 degrees x 100% ####
