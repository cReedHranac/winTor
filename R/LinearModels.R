#######################################
### Liner modeling script for winTor###
#######################################

#### Extra Paths####
if (!exists('base.path')) {
  if(.Platform$"OS.type" == "windows"){
    base.path = file.path("D:", "Dropbox", "wintor_aux")
  } else {
    base.path = "~/Dropbox/winTor_aux"
  }
}

win.dat <- file.path(base.path, "data")
win.res <- file.path(base.path, "Results")
## The %!in% opperator 
'%!in%' <- function(x,y)!('%in%'(x,y))


#### Data ####
dur <- read.csv("data/durationDataReferenced.csv")
mass <- read.csv("data/massDataReferenced.csv")

## Co-variates
library(raster)
env.names <- c("NA_dem", "NA_northing", "NA_nFrostyDays",
               "NA_nonGrowingDays", "NA_nDaysFreeze", "NA_OG1k")
env.stk <- raster::subset(stack(list.files(win.dat, pattern = "NA_*", full.names = T)), env.names)

## ammending to have co-variate data
coordinates(mass) <- ~ Long + Lat
proj4string(mass) <- proj4string(env.stk)
mass.df <- as.data.frame(cbind(mass, raster::extract(env.stk, mass)))

coordinates(dur) <- ~ Long + Lat
proj4string(dur) <- proj4string(env.stk)
dur.df <- as.data.frame(cbind(dur, raster::extract(env.stk, dur)))

#### preliminary lm to determine potential outlier points ####
library(tidyverse)
mod.form <- function(x, coVar){
  ##Function to write out the formulas for me
  ## x is to be the item predicted
  ## covar is to be a list of the names oc covariates
  
  #univariate models
  l1 <- list()
  for(i in 1:length(coVar)){
    l1[[i]] <- as.formula(paste(x,"~",coVar[[i]]))
  }
  
  #with Norhting
  coVar2 <- coVar[-2]
  l2 <- list()
  for(i in 1:length(coVar2)){
    l2[[i]] <- as.formula(paste(x,"~",coVar[[2]],"+",coVar2[[i]]))
  }
  
  #with Northing and DEM
  coVar3 <- coVar[3:length(coVar)]
  l3 <- list()
  for(i in 1:length(coVar3)){
    l3[[i]] <- as.formula(paste(x,"~",coVar[[2]],"+",coVar[[1]],"+",coVar3[[i]]))
  }
  
  list.mods <- c(l1, l2, l3)
  
  return(list.mods)
}

library(caret)
cross.lm <- function(predictor, forms, x){
  ##function for preforming leave one out crossvalidation and determing
  ##which points are potentially over influencing the models
  # pred is to be what you want to predict
  # forms is a list of formulas generated by mod.form
  # x is the dataframe from which all the data comes from
  
  ##control statment for caret
  train_control <- trainControl(method="LOOCV", returnResamp = "all")
  
  # run the leave one out validation on each of the points and return pvals
  pred = list()
  for (i in 1:nrow(x)) {
    test = x[i,]
    train = x[-i,]
    mod = lm(forms, data=train)
    pred_fit = predict.lm(mod, test, interval="prediction", se.fit=TRUE)
    pred[[i]] <- cbind(pred_fit$fit,
                      se=pred_fit$se.fit,
                      res.scale=pred_fit$residual.scale,
                      df=pred_fit$df,
                      obs=test[,predictor])
  }
  
  pred = bind_rows(lapply(pred, as.data.frame))
  
    ## finds p val for observations, if outside of window of obs adj.pval will be low
  pval.pred <- pred %>% mutate(pred.sd = sqrt(se^2 + res.scale^2),
                               tval = (obs - fit) / pred.sd,
                               pval = 2*pt(abs(tval), df=df, lower.tail = FALSE)) %>%
    mutate(padj = p.adjust(pval)) %>% arrange(pval) %>%
    dplyr::filter(padj < 1)
  
  if(nrow(pval.pred) > 0){
    out <- list(df = as.data.frame(pval.pred),formula =  forms)  
  } else{
    out <- NA
  }

  return(out)
}

cross.wrapper <- function(predictor, coVarNames, df){
  ##function to wrapp and summarize cross.lm
  # predictor is the name of the variable to be predicted across
  # coVarNames is the list of predictor names
  # df is the name that all the junk comes from 
  
  #create model formulas
  model.formulas <- mod.form(x = predictor, coVar = coVarNames)
  
  #run crossvalidation protocol
  cross.list <- lapply(X = model.formulas,
                       FUN = cross.lm,
                       predictor = predictor,
                       x = df)
  #breaks when you have non-uniqe fitting values in the predictors
  #would need some rework with the predict dataframe managment
  # obs <- list()
  # v <- 1
  # for(i in 1:length(cross.list)){
  #   if(!is.na(cross.list[[i]])){
  #     for(j in 1:nrow(cross.list[[i]]$df))
  #       obs.sub <- cbind(df[which(df[,predictor] == cross.list[[i]]$df[j,"obs"]),],
  #                      pval = cross.list[[i]]$df[,"padj"])
  #     obs[[v]] <- list(formula = cross.list[[i]]$formula, records = obs.sub)
  #     v <- v+1
  #   }
  # }
  # 
  # return(obs)
  return(cross.list)
}


##Duration
dur.points <- cross.wrapper(predictor = "winter.duration", 
                       coVarNames = env.names,
                       df = dur.df)
## 2 points, but never that low of adj p=val
## acptable adjusted p-values so I'd say they're fine
## Ask Jonathan: Are these values accecptible? 

mass.points <- cross.wrapper(predictor = "avgMass",
                             coVarNames = env.names,
                             df = mass.df)
## The 14.5 point from New York pops out in every intance and has a super low p-val
mass.df <- mass.df[-which(mass.df$avgMass==14.5),]

#### Linear model application ####

dur.mods <- lapply(mod.form("winter.duration",coVar = env.names),
                  FUN = lm, data = dur.df )

mass.mods <- lapply(mod.form("avgMass",coVar = env.names),
                    FUN = lm, data = mass.df )
## Extracting adj.R2 as a vector from each
modnames = c("dem",
             "northing",
             "frost",
             "growing",
             "freeze",
             "OG",
             "north + dem",
             "north + frost",
             "north + growing",
             "north + freeze",
             "north + OG",
             "north + dem + frost",
             "north + dem + growing",
             "north + dem + freeze",
             "north + dem + OG")

r2.durModels <- as.data.frame(cbind(Modnames=unlist(modnames),
                      R2 =unlist(lapply(dur.mods,
                             function(x){summary(x)$ adj.r.squared}))))
r2.massModels <- as.data.frame(cbind(Modnames=unlist(modnames),
                       R2 =unlist(lapply(mass.mods,
                              function(x){summary(x)$ adj.r.squared}))))

#### AIC Model Selection ####
library(AICcmodavg)
dur.AIC <- aictab(dur.mods,
                  modnames = c("dem",
                               "northing",
                               "frost",
                               "growing",
                               "freeze",
                               "OG",
                               "north + dem",
                               "north + frost",
                               "north + growing",
                               "north + freeze",
                               "north + OG",
                               "north + dem + frost",
                               "north + dem + growing",
                               "north + dem + freeze",
                               "north + dem + OG"))

mass.AIC <- aictab(mass.mods,
                   modnames = c("dem",
                                "northing",
                                "frost",
                                "growing",
                                "freeze",
                                "OG",
                                "north + dem",
                                "north + frost",
                                "north + growing",
                                "north + freeze",
                                "north + OG",
                                "north + dem + frost",
                                "north + dem + growing",
                                "north + dem + freeze",
                                "north + dem + OG"))
##Write Tables out
#append R2 onto them * Assumes that model order has not been shifted at all. 
durTableOut <- left_join(dur.AIC, r2.durModels)
massTableOut <- left_join(mass.AIC, r2.massModels)



write.csv(durTableOut, file =  file.path(win.res, 'durationResultsTable.csv'), row.names = F)
write.csv(massTableOut, file =  file.path(win.res, 'massResultsTable.csv'), row.names = F)

#### Variogram of the top models ####
library(gstat)

#top model duration
dur.mod <- formula(dur.mods[[12]])
dur.mod.df <- dur.df

#Create locations points
coordinates(dur.mod.df) <- ~ Long + Lat
proj4string(dur.mod.df) <- proj4string(env.stk)

v <- variogram(dur.mod,
                data = dur.mod.df)
v.exp = fit.variogram(v, vgm("Exp"), fit.kappa = T)
v.mat <- fit.variogram(v, vgm("Mat"), fit.kappa = T)
v.sph <- fit.variogram(v, vgm("Sph"), fit.kappa = T)

par(mfrow = c(1,3))

plot(v, v.exp)
plot(v, v.mat)
plot(v, v.sph)

library(gridExtra)
Variogram.dur <- grid.arrange(plot(v, v.exp),
                              plot(v, v.mat),
                              plot(v, v.sph),
                              ncol = 1)

ggsave( file.path(win.res,"fig", "varioDuration.pdf"),
       plot = Variogram.dur,
       device = cairo_pdf,
       width = 4,
       height = 4,
       units = "in")

### same for Mass
mass.mod <- formula(mass.mods[[10]])
mass.mod.df <- mass.df

coordinates(mass.mod.df) <- ~ Long + Lat
proj4string(mass.mod.df) <- proj4string(env.stk)

q <- variogram(mass.mod,
               data = mass.mod.df)
q.exp = fit.variogram(q, vgm("Exp"), fit.kappa = T)
q.mat <- fit.variogram(q, vgm("Mat"), fit.kappa = T)
q.sph <- fit.variogram(q, vgm("Sph"), fit.kappa = T)

par(mfrow = c(1,3))

plot(q, q.exp)
plot(q, q.mat)
plot(q, q.sph)

Variogram.mass <-  grid.arrange(plot(q, q.exp),
                                plot(q, q.mat),
                                plot(q, q.sph),
                                ncol = 1)

ggsave( file.path(win.res,"fig", "varioMass.pdf"),
        plot = Variogram.mass,
        device = cairo_pdf,
        width = 4,
        height = 4,
        units = "in")



#### Predictions and confidince bounds ####
lmRasterIntervals <- function(model, coVars, outName){
  conffun <- function(model, data) {
    v <- predict(model, data, interval = "confidence")
    cbind(p=as.vector(v[,"fit"]), lwr=as.vector(v[,"lwr"]), upr=as.vector(v[,"upr"]) )
  }
  
  conf.int <- raster::predict(model, object = coVars, fun = conffun, index = 1:3)
  names(conf.int) <- c("p", "lwr", "upr")
  
  writeRaster(x = conf.int,
              filename = file.path(win.res, outName),
              format = "GTiff",
              bylayer = T,
              suffix = "names",
              overwrite = T)
  
}

dur.top.form <- mod.form("winter.duration",coVar = env.names)[[3]]
dur.top.mod <- lm(dur.top.form, data = dur.df)
lmRasterIntervals(dur.top.mod,
                  coVars = env.stk,
                  outName = "durationRaster")


mass.top.form <- mod.form("avgMass",coVar = env.names)[[10]]
mass.top.mod <- lm(mass.top.form, data = mass.df)
lmRasterIntervals(mass.top.mod,
                  coVars = env.stk,
                  outName = "massRaster")
gc()

#### Running hibernation model ####
# ## Step one run the batwintor model on mylu
# library(batwintor)
# ## creating hibernation model 
# mylu.params <- batLoad(bat.params, "MYLU")
# ##Changing the mass to the predicted average mass 
# mylu.params$Mass <- 8.6
# fung.ch <- fungalSelect("Chaturvedi")
# env <- buildEnv(temp = c(-4,10), #temperatures in degrees C
#                 pct.rh = c(46, 100), #precent humidity
#                 range.res.temp = 1, #resolution of the temperature
#                 range.res.rh = 1, #resolution of the humidithy
#                 twinter = 12, #maximal length of winter (in this case I have months)
#                 winter.res = 1) #resolution of the time vector in vectors
# 
# mylu.mod <- hibernationModel(env = env,
#                              bat.params = mylu.params,
#                              fung.params = fung.ch)
# 
# data.table::fwrite(x = mylu.mod,
#                    file = "D://Dropbox/winTor_aux/data/myluDynamicModel.csv" )
# 
# 
# mylu.mod <- fread(file.path(win.dat, "myluDynamicModel.csv"))
# 
# ###Creating an alternative model with the pfly at 30%
# ## creating hibernation model 
# mylu.params <- batLoad(bat.params, "MYLU")
# ##Changing the mass to the predicted average mass 
# system.time({
#   mylu.params$Mass <- 8.6
#   mylu.params$pFly <- .3
#   fung.ch <- fungalSelect("Chaturvedi")
#   env <- buildEnv(temp = c(-4,10), #temperatures in degrees C
#                   pct.rh = c(46, 100), #precent humidity
#                   range.res.temp = 1, #resolution of the temperature
#                   range.res.rh = 1, #resolution of the humidithy
#                   twinter = 12, #maximal length of winter (in this case I have months)
#                   winter.res = 1) #resolution of the time vector in vectors
#   
#   mylu.mod <- hibernationModel(env = env,
#                                bat.params = mylu.params,
#                                fung.params = fung.ch)
#   
#   data.table::fwrite(x = mylu.mod,
#                      file = "D://Dropbox/winTor_aux/data/myluDynamicModel_fly.csv" )
# }
# )
#### Creating the fat required rasters #####
## step two, add spatial aspect
survivalFat <- function(mod.df, pct.rh.rast, temp.rast, win.rast){
  ### Function for converting the amount dynamic hibernation model results into 
  ### grams of fat and appling those againt winter duration
  ## mod.df <- dynamic hibernation model results
  ## pch.rh.rast <- relative humidity raster to apply spatially
  ## temp.rast <- temperature raster to apply spatially
  ## win.rast <- winter duration raster to apply spatially
  
  #Raster modifications for Kelvin temperatures
  if(summary(temp.rast)[1] > 200){
    temp.c <- temp.rast - 273
  } else{
    temp.c <- temp.rast
  }
  
  #Creating output raster dimensions
  out <- raster(pct.rh.rast); values(out) <- NA
  out.s <- stack(out,out); names(out.s) <- c("fat.inf", "fat.null")
  
  #Extract data from rasters  to matrix for speed
  pct.rh <- as.matrix(pct.rh.rast, nrow = nrow(pct.rh.rast), ncol = ncol(pct.rh.rast))
  temp <- as.matrix(temp.c, nrow = nrow(temp.c), ncol = ncol(temp.c))
  win <- as.matrix(win.rast, nrow = nrow(win.rast), ncol = ncol(win.rast))
  
  ## shifting hours to days
  mod.dif <- mod.df %>%
    mutate_(days = ~hour.to.day(time)) 
  
  ####Look Up Table ####
  #Vectors for look up table structure
  Ta_vals <- unique(mod.dif$Ta)
  pct.rh_vals <- unique(mod.dif$pct.rh)
  days_vals <- unique(mod.dif$days)
  
  #Look Up Table
  lut <- array(NA, dim=c(length(Ta_vals), length(pct.rh_vals), length(days_vals),  2)) # 2 for fat.inf and fat.null
  dimnames(lut)[[1]] <- Ta_vals
  dimnames(lut)[[2]] <- pct.rh_vals
  dimnames(lut)[[3]] <- days_vals
  dimnames(lut)[[4]] <- c("fat.inf", "fat.null")
  
  
  #Fill look up table
  for (i in seq_len(nrow(mod.dif))) {
    d <- mod.dif[i,]
    if (i %% 10000 == 0) {
      cat("Look up table generation up to", i, "of", nrow(mod.dif), "\n")
    }
    lut[as.character(d$Ta), as.character(d$pct.rh), as.character(d$days),] <- c(d$g.fat.consumed,
                                                                                d$n.g.fat.consumed)
  }
  
  ####Find closest####
  find_closest <- function(x, y) {
    # Find the closest item in the vector y to x.
    # NOTE: Assumes that y is increasing, equi-spaced vector
    dy <- (y[length(y)] - y[1]) / (length(y)-1)
    wch <- round((x - y[1]) / dy + 1)
    # check the range.
    clamp <- function(x, xmin, xmax) {
      min(max(x, xmin),xmax)
    }
    
    clamp(wch, 1, length(y))
  }
  
  #Run lookup
  for(j in 1:nlayers(out.s)){
    #Create output matrix
    out.z <- matrix(ncol = ncol(pct.rh), nrow = nrow(pct.rh))
    for(i in 1:length(pct.rh)){
      # first find the closest humidity and Ta
      if(i %% 1000 == 0){
        cat("Raster layer: ", j, "of", nlayers(out.s), "up to", i, "of", length(pct.rh), "\n")
      }
      pct.rh_i <- find_closest(pct.rh[[i]], pct.rh_vals)
      Ta_i  <- find_closest(temp[[i]], Ta_vals)
      win_i <- find_closest(win[[i]], days_vals)
      out.z[[i]] <- lut[Ta_i, pct.rh_i, win_i, j]
    }
    # Set values back from matrix to raster
    out.s[[j]] <- setValues(out.s[[j]], out.z)
  }
  return(out.s)
}
survivalMetrics <- function(mod.df, pct.rh.rast, temp.rast, win.rast){
  ### Function for converting the amount dynamic hibernation model results into 
  ### grams of fat and appling those againt winter duration
  ## mod.df <- dynamic hibernation model results
  ## pch.rh.rast <- relative humidity raster to apply spatially
  ## temp.rast <- temperature raster to apply spatially
  ## win.rast <- winter duration raster to apply spatially
  
  #Raster modifications for Kelvin temperatures
  if(summary(temp.rast)[1] > 200){
    temp.c <- temp.rast - 273
  } else{
    temp.c <- temp.rast
  }
  
  #Creating output raster dimensions
  out <- raster(pct.rh.rast); values(out) <- NA
  out.s <- stack(out,out,out,out); names(out.s) <- c("fat.inf", "fat.null",
                                                     "max.inf", "max.null")
  
  #Extract data from rasters  to matrix for speed
  pct.rh <- as.matrix(pct.rh.rast, nrow = nrow(pct.rh.rast), ncol = ncol(pct.rh.rast))
  temp <- as.matrix(temp.c, nrow = nrow(temp.c), ncol = ncol(temp.c))
  win <- as.matrix(win.rast, nrow = nrow(win.rast), ncol = ncol(win.rast))
  
  ## shifting hours to days
  mod.dif <- mod.df %>%
    mutate_(days = ~hour.to.day(time)) %>%
    group_by_(~Ta, ~pct.rh) %>%
    mutate_(max.inf = ~max(days*surv.inf),
            max.null = ~max(days*surv.null)) %>%
    ungroup
  
  ####Look Up Table ####
  #Vectors for look up table structure
  Ta_vals <- unique(mod.dif$Ta)
  pct.rh_vals <- unique(mod.dif$pct.rh)
  days_vals <- unique(mod.dif$days)
  
  #Look Up Table
  lut <- array(NA, dim=c(length(Ta_vals), length(pct.rh_vals), length(days_vals),  4)) # 2 for fat.inf and fat.null
  dimnames(lut)[[1]] <- Ta_vals                                                        # 2 more for the max time
  dimnames(lut)[[2]] <- pct.rh_vals
  dimnames(lut)[[3]] <- days_vals
  dimnames(lut)[[4]] <- c("fat.inf", "fat.null", "max.inf", "max.null")
  
  
  #Fill look up table
  for (i in seq_len(nrow(mod.dif))) {
    d <- mod.dif[i,]
    if (i %% 10000 == 0) {
      cat("Look up table generation up to", i, "of", nrow(mod.dif), "\n")
    }
    lut[as.character(d$Ta), as.character(d$pct.rh), as.character(d$days),] <- c(d$g.fat.consumed,
                                                                                d$n.g.fat.consumed,
                                                                                d$max.inf,
                                                                                d$max.null)
  }
  
  ####Find closest####
  find_closest <- function(x, y) {
    # Find the closest item in the vector y to x.
    # NOTE: Assumes that y is increasing, equi-spaced vector
    dy <- (y[length(y)] - y[1]) / (length(y)-1)
    wch <- round((x - y[1]) / dy + 1)
    # check the range.
    clamp <- function(x, xmin, xmax) {
      min(max(x, xmin),xmax)
    }
    
    clamp(wch, 1, length(y))
  }
  
  #Run lookup
  for(j in 1:nlayers(out.s)){
    #Create output matrix
    out.z <- matrix(ncol = ncol(pct.rh), nrow = nrow(pct.rh))
    for(i in 1:length(pct.rh)){
      # first find the closest humidity and Ta
      if(i %% 100000 == 0){
        cat("Raster layer: ", j, "of", nlayers(out.s),
            " -- ", (i/length(pct.rh))*100, "% complete\n")
      }
      pct.rh_i <- find_closest(pct.rh[[i]], pct.rh_vals)
      Ta_i  <- find_closest(temp[[i]], Ta_vals)
      win_i <- find_closest(win[[i]], days_vals)
      out.z[[i]] <- lut[Ta_i, pct.rh_i, win_i, j]
    }
    # Set values back from matrix to raster
    out.s[[j]] <- setValues(out.s[[j]], out.z)
  }
  
  # ammend the max survived layers
  out.s[[3]] <- out.s[[3]] - win.rast;names(out.s)[[3]] <- "survDays.inf"
  out.s[[4]] <- out.s[[4]] - win.rast;names(out.s)[[4]] <- "survDays.null"
  return(out.s)
}


## spatial layer
win <- raster(file.path(win.res, "durationRaster_p.tif"))
## hibernation model
mylu.mod <- data.table::fread(file = "D://Dropbox/winTor_aux/data/myluDynamicModel.csv" )
## humidity conditions
rh.cond <- c(80, 85, 90, 95, 98, 100)
## temperature conditions
temp.cond <- c(2, 4)

micro.cond <- expand.grid(rh.cond, temp.cond)
names(micro.cond)<- c("rh", "temp")

system.time(
for(i in 1:nrow(micro.cond)){
  ## create the fixed condition rasters
  rh.fix   <- calc(win, function(x) ifelse(!is.na(x), micro.cond$rh[[i]], NA))
  temp.fix <- calc(win, function(x) ifelse(!is.na(x), micro.cond$temp[[i]],NA))
  ## run the calculations
  fat.req <- survivalMetrics(mod.df = mylu.mod,
                         pct.rh.rast = rh.fix,
                         temp.rast = temp.fix,
                         win.rast = win)
  writeRaster(fat.req,
              filename = file.path(win.res,
                                   paste0("myluFatReq_",micro.cond$rh[[i]],"_",
                                          micro.cond$temp[[i]], ".tif")),
              format = "GTiff",
              bylayer = T,
              suffix = "names",
              overwrite = T)
  
  rm(rh.fix, temp.fix, fat.req)
  gc()
  
})

# 
# ## define the static hibernation conditions
# # Condition 1: 4 Degrees C and 98% relative humidity
# temp4 <- calc(win, function(x) ifelse(!is.na(x),4,NA))
# rh98 <- calc(win, function(x) ifelse(!is.na(x), 98, NA))
# fat.C1 <- survivalFat(mod.df = mylu.mod,
#                       pct.rh.rast = rh98,
#                       temp.rast = temp4,
#                       win.rast = win)
# writeRaster(fat.C1,
#             filename = file.path(win.res, "MYLU_fatRequired__4_98.tif"),
#             format = "GTiff",
#             bylayer = T,
#             suffix = "names",
#             overwrite = T)
# ## Clean up for ram 
# rm(fat.C1,rh98,temp4);gc()
# 
# ## Condition 2: 2 Degrees C and 100% relative humidity
# temp2 <- calc(win, function(x) ifelse(!is.na(x),2,NA))
# rh100 <- calc(win, function(x) ifelse(!is.na(x),100,NA))
# fat.C2 <- survivalFat(mod.df = mylu.mod,
#                       pct.rh.rast = rh100,
#                       temp.rast = temp2,
#                       win.rast = win)
# writeRaster(fat.C2,
#             filename = file.path(win.res, "MYLU_fatRequired__2_100.tif"),
#             format = "GTiff",
#             bylayer = T,
#             suffix = "names",
#             overwrite = T)
# ## Clean up for ram 
# rm(fat.C2,rh100,temp2);gc()
# 
# #### uncertianty win ####
# win.lwr <- raster(file.path(win.res, "durationRaster_lwr.tif"))
# ## Clean up for ram 
# 
# 
# 
# 
# 
# win.upr <- raster(file.path(win.res, "durationRaster_upr.tif"))
# 
# fat.upr <- survivalFat(mod.df = mod.alt,
#                        pct.rh.rast = rh.fix,
#                        temp.rast = mat.fix,
#                        win.rast = win.upr)
# 
# writeRaster(fat.upr,
#             filename = file.path(win.res, "MYLU_fatRequired_upr.tif"),
#             format = "GTiff",
#             bylayer = T,
#             suffix = "names",
#             overwrite = T)
# rm(win.upr, fat.upr)
# gc()
# 
# 
# #### uncertianty win ####
# temp4 <- calc(win, function(x) ifelse(!is.na(x),4,NA))
# rh98 <- calc(win, function(x) ifelse(!is.na(x), 98, NA))
# win.lwr <- raster(file.path(win.res, "durationRaster_lwr.tif"))
# 
# fat.lwr <- survivalFat(mod.df = mylu.mod,
#                        pct.rh.rast = rh100,
#                        temp.rast = temp2,
#                        win.rast = win.lwr)
# 
# writeRaster(fat.lwr,
#             filename = file.path(win.res, "MYLU_fatRequired_LWR.tif"),
#             format = "GTiff",
#             bylayer = T,
#             suffix = "names",
#             overwrite = T)
# rm(win.lwr, fat.lwr)
# gc()
# 
# 
# win.upr <- raster(file.path(win.res, "durationRaster_upr.tif"))
# 
# fat.upr <- survivalFat(mod.df = mylu.mod,
#                        pct.rh.rast = rh100,
#                        temp.rast = temp2,
#                        win.rast = win.upr)
# 
# writeRaster(fat.upr,
#             filename = file.path(win.res, "MYLU_fatRequired_upr.tif"),
#             format = "GTiff",
#             bylayer = T,
#             suffix = "names",
#             overwrite = T)
# rm(win.upr, fat.upr)
# gc()
# 
